#!/usr/bin/env perl
use FindBin qw($Bin);
use lib "$Bin/lib";

use strict;
use AutoHarp::Events::DrumTrack;
use AutoHarp::MusicBox::Base; 
use AutoHarp::Constants;
use AutoHarp::Config;
use AutoHarp::Genre;
use File::Copy;
use MIDI;
use JSON;

my $dir = $ARGV[0] || ".";
my $DS  = ($^O =~ /MSWin/) ? chr(92) : "/";
my @StartGenres = ('Country',
		   'Metal',
		   'Rock',
		   'Electronic',
		   'Big Easy',
		   'Funk',
		   'Hip Hop',
		   'R and B',
		   'Prog',
		   'Blues',
		   'Fusion',
		   'Punk',
		   'Twisted',
		   'Breakbeat',
		   'Jazz',
		   'World'
		  );

my $GenreList;
#this may fail if there are no genres
eval {
  $GenreList = AutoHarp::Genre::Genres();
};
if ($@) {
  print "No genres found yet\n";
}

foreach my $s (@StartGenres) {
  push(@$GenreList,$s) if (!scalar grep {$_ eq $s} @$GenreList);
}

recProc($dir);

exit(0);

sub recProc {
  my $dir       = shift;
  if (opendir(D,$dir)) {
    foreach my $i (grep {/\w/} readdir(D)) {
      if (-d "$dir${DS}$i") {
	recProc("$dir${DS}$i");
      } elsif ($i =~ /\.mid/) {
	my $data = midi2genredata($dir,$i);
	if (!$data) {
	  print "Couldn't find a drum track in $dir/$i, skipping...\n";
	  next;
	}
	my $genre = findGenre($dir,$i) || chooseGenre("$dir${DS}$i");
	my $g = AutoHarp::Genre->new($genre,1);
	$g->addPattern($data,1);
	$g->save();
	print "Added $data->{$ATTR_BARS} bar loop from $dir${DS}$i to $genre as a $data->{$ATTR_TAG}\n"; 
      } else {
	print "Ignoring file $dir${DS}$i (non-midi)\n";
      }
    }
    closedir(D);
  } else {
    die "FAILED TO OPEN $dir: $!\n";
  }
}
      
sub midi2genredata {
  my $directory = shift;
  my $file      = shift;
  my $tracks;
  eval {
    $tracks = AutoHarp::Events::DrumTrack->fromFile("$directory${DS}$file");
  };
  if ($@) {
    print "Nothing from $file: $@";
    return;
  }
  my $guide = $tracks->[0];
  my $track = $tracks->[1];
  my $clock = $guide->clock();
  my $origFile = $file;
  my $newFile  = AutoHarp::Config::GenreLoopFile($file);
  while (-f $newFile) {
    my @cp  = split(/\./,$file);
    my $tag = pop(@cp) || "midi";
    my $f   = join("",@cp);
    if ($f !~ /\d$/) {
      $f .= "0";
    }
    $f++;
    $newFile = AutoHarp::Config::GenreLoopFile($file = "$f.$tag");
  }
  if (File::Copy::syscopy("$directory${DS}$origFile",$newFile)) {
    my $data    =  {
		    $ATTR_BARS    => $guide->measures(),
		    $ATTR_METER   => $guide->clock->meter(),
		    $ATTR_TEMPO   => $guide->clock->tempo(),
		    $ATTR_PATTERN => $track->toDataStructure($guide),
		    $ATTR_FILE    => $file
		   };
    print JSON->new()->pretty()->encode($data->{$ATTR_PATTERN});
    tagLoop($data,$track,$guide->clock,$directory,$file);
    return $data;
  } else {
    die "Couldn't copy file over into database! Check permissions on " .
      AutoHarp::Config::GenreFileRoot() . " and try again";
  }
}

sub findGenre {
  my $dirName = shift;
  my $fileName = shift;
  my $r = ($^O =~ /MSWin/) ? qr(\\) : qr(/);
  my @tokens = grep {/\w/} split($r,$dirName);
  unshift(@tokens,$fileName);
  my $genre;
  foreach my $t (@tokens) {
    $t =~ s/\s*&\s*/ and /i;
    foreach my $g (@$GenreList) {
      if (lc($t) eq lc($g)) {
	#direct match, return that
	return $g;
      } elsif ($t =~ /^$g/i) {
	#starts the name of a directory, use that for now
	$genre = $g;
      } elsif (!$genre && $t =~ /$g/i) {
	#is contained in the name of a directory, and we have nothing else
	$genre = $g;
      }
    }
  }
  return $genre;
}

sub chooseGenre {
  my $file = shift;
  print "Couldn't find genre for $file.\n";
  my $idx = 1;
  for(; $idx <= scalar @$GenreList; $idx++) {
    printf "%2d) %s\n",$idx,$GenreList->[$idx - 1];
  }
  printf "%2d) New Genre\n",$idx;
  my $chosenGenre;
  while (1) {
    printf "==> ";
    chomp(my $chosen = <STDIN>);
    if ($chosen > 0 && $chosen <= scalar @$GenreList + 1) {
      $chosenGenre = $GenreList->[$chosen - 1];
      last;
    }
    print "That was an invalid selection. YOU SUCK.\n";
  }
  if (!$chosenGenre) {
    print "Enter new genre ==> ";
    chomp($chosenGenre = <STDIN>);
  }
  push(@$GenreList,$chosenGenre) 
    if (!scalar grep {lc($_) eq $chosenGenre} @$GenreList);

  return $chosenGenre;
}

sub tagLoop {
  my $data      = shift;
  my $track     = shift;
  my $clock     = shift;
  my $directory = shift;
  my $name      = shift;
  
  my $file      = "$directory${DS}$name";
  
  if ($track->duration() < $clock->measureTime() &&
      $track->soundingTime > $clock->beatTime() * 2) {
    #call this a lead-in, no matter what they say
    return $data->{$ATTR_TAG} = $SONG_ELEMENT_LEADIN;
  }

  foreach my $t ($SONG_ELEMENT_FILL,
		 $SONG_ELEMENT_VERSE,
		 $SONG_ELEMENT_CHORUS,
		 $SONG_ELEMENT_BRIDGE
		) {
    if ($name =~ /$t/i) {
      return $data->{$ATTR_TAG} = $t;
    }
  }
  
  if ($file =~ /($SONG_ELEMENT_INTRO|$SONG_ELEMENT_OUTRO|$SONG_ELEMENT_SOLO|$SONG_ELEMENT_FILL)/i) {
    return $data->{$ATTR_TAG} = $SONG_ELEMENT_FILL;
  }

  return $data->{$ATTR_TAG} = $SONG_ELEMENT_VERSE;
}
    
